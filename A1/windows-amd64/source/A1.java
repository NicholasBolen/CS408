/* autogenerated by Processing revision 1286 on 2022-09-29 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class A1 extends PApplet {

// CS408 - Assignment 1
// Nicholas Bolen
// #200455709

// List of all particles
ArrayList<Particle> particles = new ArrayList<>();
// Controller particles
Particle control, control2, activeController;
Boolean secondaryEnabled = false, guidesEnabled = false;
float baseAngle = 0;

// Init
 public void setup()
{
    /* size commented out by preprocessor */;
    frameRate(60);
    control = new Particle();
    particles.add(new Particle(control));
    activeController = control;
}

// Create new particle and call update function on each frame
 public void draw()
{    
    // Black background
    background(0);
    
    // Create new particle
    Particle p2 = new Particle(control);
    
    // Creative feature - display if feature activated & currently selected controller
    String t;
    if (activeController == control)
        t = "1";
    else t = "2";
    if (secondaryEnabled) {
        noStroke();
        fill(0, 255, 0, 120);
        rect(10, 10, 40, 40);
        fill(255, 255, 255, 120);
        textSize(40);
        text(t, 20, 40); 
    }
    else {
        noStroke();
        fill(255, 0, 0, 120);
        rect(10, 10, 40, 40);
        fill(255, 255, 255, 120);
        textSize(40);
        text(t, 20, 40); 
    }
    
    // Creative feature - choose value within range if enabled
    if (secondaryEnabled) {
        p2.position = new PVector(
            round(urandom(control.position.x, control2.position.x)),
            round(urandom(control.position.y, control2.position.y))
        );
        p2.size = round(urandom(control.size, control2.size));
        p2.shape = urandom(control.shape, control2.shape);
        p2.r = round(urandom(control.r, control2.r));
        p2.g = round(urandom(control.g, control2.g));
        p2.b = round(urandom(control.b, control2.b));
        p2.speed = round(urandom(control.speed, control2.speed));
        p2.alpha = round(urandom(control.alpha, control2.alpha));
    }
    // Creative feature - otherwise, copy current primary values
    else control2 = new Particle(control);
    
    
    // Apply Z rotation of baseAngle +- 30 degrees
    float angle = baseAngle + random(-PI/6, PI/6);
    // Rotation matrix
    float[][] a = {
        {cos(angle), -sin(angle), 0},
        {sin(angle), cos(angle), 0},
        {0, 0, 1}
    };
    p2.direction = matrixToVec(matmul(a, p2.direction));
    
    // Add new particle and call update function
    particles.add(new Particle(p2));
    update(particles);
    
    
    // Creative feature - draw guide lines if enabled
    if (guidesEnabled)
    {
        control.renderOutline();
        if (secondaryEnabled) control2.renderOutline();
    }
}

// Rendering and updating all particles
 public void update(ArrayList<Particle> ps)
{
    // Iterate over list backwards so we can delete particles without issue
    for (int i = ps.size() - 1; i >= 0; i--) {
        Particle p = ps.get(i);

        p.render(); // render before adjusting position so we display particles added this frame at 0,0
        p.age++;
        if (p.age >= 60)
            ps.remove(p);
        else
            p.position.add(PVector.mult(p.direction, p.speed));
    }
}

// Watching for keypresses / user commands
 public void keyPressed()
{
    // Colour components
    if (key == 'r' && activeController.r > 0)
        activeController.r--;
    else if (key == 'R' && activeController.r < 255)
        activeController.r++;
    if (key == 'g' && activeController.g > 0)
        activeController.g--;
    else if (key == 'G' && activeController.g < 255)
        activeController.g++;
    if (key == 'b' && activeController.b > 0)
        activeController.b--;
    else if (key == 'B' && activeController.b < 255)
        activeController.b++;
        
    // Transparency
    if (key == 't' && activeController.alpha > 0)
        activeController.alpha--;
    else if (key == 'T' && activeController.alpha < 255)
        activeController.alpha++;
    
    // Size
    if (key == '-' && activeController.size > 0)
        activeController.size--;
    else if (key == '+' && activeController.size < 200)
        activeController.size++;
    
    // Emitter position
    if (key == 'a' && activeController.position.x > 0)
        activeController.position.x -= 3;
    else if (key == 'd' && activeController.position.x < width)
        activeController.position.x += 3;
    if (key == 'w' && activeController.position.y > 0)
        activeController.position.y -= 3;
    else if (key == 's' && activeController.position.y < height)
        activeController.position.y += 3;
    
    // Speed
    if (keyCode == DOWN && activeController.speed > 0)
        activeController.speed--;
    else if (keyCode == UP && activeController.speed < 10)
        activeController.speed++;
    
    // Base angle / movement direction
    if (keyCode == LEFT)
        baseAngle -= 0.01f;
    else if (keyCode == RIGHT)
        baseAngle += 0.01f;
    
    // Shape
    if (key == 'h' && activeController.shape > 0.25f)
        activeController.shape -= 0.25f;
    else if (key == 'H' && activeController.shape < 4)
        activeController.shape += 0.25f;
        
    
    // Creative Feature
    // Reset
    if (key == '0') {
        control = new Particle();
        control2 = new Particle(control);
        secondaryEnabled = false;
        activeController = control;
        guidesEnabled = false;
        baseAngle = 0;
    }
    
    // Edit primary controller
    if (key == '1') {
        activeController = control;
    }
    
    // Edit secondary controller
    if (key == '2' && secondaryEnabled) {
        activeController = control2;
    }
    
    // Enable/disable secondary controller
    if (key == '3') {
        secondaryEnabled = !secondaryEnabled;
        activeController = control;
    }
    
    // Enable/disable guides
    if (key == '4') {
        guidesEnabled = !guidesEnabled;
    }
}
// The Particle class

class Particle {
    // Params
    PVector position;
    PVector direction;
    int size;
    float shape;
    int r;
    int g;
    int b;
    int speed;
    int age;
    int alpha;

    // Default constructor
    Particle() {
        position = new PVector(width / 2, height / 2);
        direction = new PVector(1, 0);
        size = 100;
        shape = 1;
        r = 64; // ~25% of 255
        g = 64;
        b = 64;
        speed = 5;
        age = 0;
        alpha = 255;
    }

    // Copy constructor
    Particle(Particle p) {
        position = p.position.copy();
        direction = p.direction.copy();
        size = p.size;
        shape = p.shape;
        r = p.r;
        g = p.g;
        b = p.b;
        speed = p.speed;
        age = p.age;
        alpha = p.alpha;
    }

    // Draw function
     public void render() {
        noStroke();
        fill(r, g, b, alpha);
        
        // Clockwise corner -> edge -> corner -> edge -> ... starting top left
        beginShape();
        vertex(position.x - size/2, position.y - size/2);
        vertex(position.x - shape*size/2, position.y);
        vertex(position.x - size/2, position.y + size/2);
        vertex(position.x, position.y + shape*size/2);
        vertex(position.x + size/2, position.y + size/2);
        vertex(position.x + shape*size/2, position.y);
        vertex(position.x + size/2, position.y - size/2);
        vertex(position.x, position.y - shape*size/2);
        endShape(CLOSE);
    }
    
    // Draw outline function
     public void renderOutline() {
        strokeCap(SQUARE);
        strokeWeight(size / 10);
        stroke(r, g, b, alpha);
        noFill();
        
        // Clockwise corner -> edge -> corner -> edge -> ... starting top left
        beginShape();
        vertex(position.x - size/2, position.y - size/2);
        vertex(position.x - shape*size/2, position.y);
        vertex(position.x - size/2, position.y + size/2);
        vertex(position.x, position.y + shape*size/2);
        vertex(position.x + size/2, position.y + size/2);
        vertex(position.x + shape*size/2, position.y);
        vertex(position.x + size/2, position.y - size/2);
        vertex(position.x, position.y - shape*size/2);
        endShape(CLOSE);
    }
}
// Pick random value between a and b, independant of order passed
 public float urandom(float a, float b) {
    if(a > b)
        return random(b, a);
    return random(a, b);
}
// Matrix multiplication functions from Danial Shiffman AKA The Coding Train on YouTube
// I do not claim these as my own work, and they are only used as 
// helper functions in place of importing a math library
// https://thecodingtrain.com/
// https://youtu.be/tzsgS19RRc8

 public float[][] vecToMatrix(PVector v) {
    float[][] m = new float[3][1];
    m[0][0] = v.x;
    m[1][0] = v.y;
    m[2][0] = v.z;
    return m;
}

 public PVector matrixToVec(float[][] m) {
    PVector v = new PVector();
    v.x = m[0][0];
    v.y = m[1][0];
    if (m.length > 2) {
        v.z = m[2][0];
    }
    return v;
}

 public float[][] matmul(float[][] a, PVector b) {
    float[][] m = vecToMatrix(b);
    return matmul(a,m);
}

 public float[][] matmul(float[][] a, float[][] b) {
    int colsA = a[0].length;
    int rowsA = a.length;
    int colsB = b[0].length;
    int rowsB = b.length;

    if (colsA != rowsB) {
        println("Columns of A must match rows of B");
        return null;
    }
    float result[][] = new float[rowsA][colsB];
    
    for (int i = 0; i < rowsA; i++) {
        for (int j = 0; j < colsB; j++) {
            float sum = 0;
            for (int k = 0; k < colsA; k++) {
                sum += a[i][k] * b[k][j];
            }
            result[i][j] = sum;
        }
    }
    return result;
}


    public void settings() { size(1440, 810); }

    static public void main(String[] passedArgs) {
        String[] appletArgs = new String[] { "A1" };
        if (passedArgs != null) {
            PApplet.main(concat(appletArgs, passedArgs));
        } else {
            PApplet.main(appletArgs);
        }
    }
}
